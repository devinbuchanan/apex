Apple Human Interface Guidelines (HIG) for iOS

Designing for iOS

As you begin designing an app or game for iOS, it’s important to understand the fundamental device characteristics and interaction patterns that define the iOS experience ￼. iPhone users rely on their devices to stay connected, play games, view media, accomplish tasks, and track personal data anywhere on the go ￼. Keep the following in mind:
	•	Display: The iPhone features a medium-sized, high-resolution display ￼. Utilize the screen space to present content clearly and avoid clutter. Embrace the full-screen, edge-to-edge nature of the display – content often extends to the edges, with minimal device bezel visible during use ￼. Ensure your UI adapts to different screen sizes and orientations so it looks great on all iPhone models.
	•	Ergonomics: People typically hold an iPhone in one or both hands, and they may switch between portrait and landscape orientation as needed ￼. They usually view the screen at a distance of 1–2 feet. Design with comfortable one-handed use in mind, especially for important controls. For example, avoid placing critical buttons in the upper corners where they are hard to reach with the thumb. On iPad, consider placing key controls toward the sides in landscape so they’re reachable while the user holds the device ￼.
	•	Inputs: iOS is built around direct manipulation with Multi-Touch gestures. People interact via touch gestures (tap, swipe, drag, pinch, etc.), on-screen keyboards for text, voice control (e.g. Siri dictation), and even motion inputs (accelerometer and gyroscope) ￼. Ensure your app responds to standard gestures intuitively. Avoid defining custom gestures that use screen edges, because they can conflict with system-wide gestures (like the swipe from the edge for going back or accessing the Home screen) ￼. If you do implement a custom gesture, make sure it doesn’t interfere with these system gestures. Whenever possible, support platform conveniences like keyboard shortcuts (on iPad with hardware keyboards) and pointer (Apple Pencil or mouse) interactions to enrich the experience.
	•	Spatial interactions: Newer iOS devices support spatial interactions using technologies like the U1 ultra-wideband chip. For example, iOS can hand off audio from iPhone to a HomePod mini when the devices are brought close together ￼. If your app uses Nearby Interaction (for experiences like sharing data by proximity), request the necessary authorization and design the interaction so it feels natural and intuitive. (The system uses privacy-friendly, ephemeral identifiers during such sessions ￼.)
	•	App interactions and multitasking: iOS devices generally show one app at a time in full screen. Users often quickly switch between apps using the app switcher or gestures. Sometimes people spend just a minute or two in an app (to check updates or send a message), and other times they may engage for an hour or more (browsing the web, watching videos, or playing games) ￼. Design your app to handle frequent interruptions and resumes gracefully. Support multitasking-related interruptions – for example, save state when the app is backgrounded so users can continue where they left off ￼. Provide continuity: if your app has time-sensitive tasks (like a game), handle incoming calls or messages in a way that doesn’t punish the user for stepping away.
	•	System features: iOS provides many system features that users expect and appreciate. Integrating these consistently and appropriately makes your app feel at home on the platform. For example, iOS apps can use Home Screen Quick Actions (contextual home-screen menu items), Widgets, Spotlight search indexing, Siri Shortcuts, Share sheets (Activity views), etc., to enrich the user experience ￼. Use these features in the standard ways so users immediately understand them. For instance, if your app offers shareable content, use the system activity view for sharing ￼. If your app provides at-a-glance info, consider offering a Home Screen widget. Always use system APIs for these features to get the native look and behavior for free.

Foundations

The Foundations of the HIG cover fundamental design elements – things like color, typography, iconography, imagery, layout, motion, and accessibility – which together help you create a rich and cohesive experience ￼ ￼. Design decisions in these areas affect every part of your app’s UI. Below, we outline key guidelines for several of these foundational topics.

Color

Judicious use of color can enhance communication, evoke your brand, provide visual continuity, convey status and feedback, and help people understand information ￼. iOS provides a system color palette that looks good in various contexts. The system defines colors that work well on a variety of backgrounds and in both light and dark modes, and can even adapt automatically to vibrancy and increased contrast settings ￼. People are familiar with standard system colors, and using them helps your app feel native on the device ￼. At the same time, you may use custom colors to express a unique personality or match your brand. The HIG provides the following guidance for using color in ways people appreciate, whether you use system or custom colors ￼:

Best practices for color:
	•	Use color sparingly in non-game apps. In a typical app (not a game), overusing color can make your UI busy and reduce clarity. Instead, use color as an accent to highlight important elements or to indicate interactivity ￼. A few well-placed touches of color draw attention where needed without overwhelming the content.
	•	Don’t use the same color to mean different things. Be consistent with your use of color across the interface, especially when color is used to communicate something like status or interactive affordances. Using one color for multiple unrelated meanings will confuse users ￼. For example, if tappable text is indicated by blue color in one part of your app, avoid using blue for non-interactive text elsewhere, as this would be misleading ￼.
	•	Ensure colors work in both Light and Dark Mode. iOS supports a system-wide Dark Mode (except on watchOS which is always dark). In Dark Mode, the system automatically uses a darker palette for backgrounds, views, and controls, and can increase color vibrancy (a dynamic blending of foreground and background colors) to make content stand out on dark backgrounds ￼. System colors automatically adapt to light/dark. If you use custom colors, you must supply appropriate variants for light and dark appearances so your UI remains clear in both modes ￼. (For guidance on designing for Dark Mode, see Apple’s developer documentation ￼.)
	•	Test your color scheme in various environments. Colors can appear differently under changing ambient light. For instance, bright sunlight or very dim lighting can affect perceived contrast. Make sure your app’s colors provide enough contrast and remain visually appealing in a range of real-world conditions ￼. Test on actual devices in different lighting scenarios. Also, if your app’s users will frequently view content on devices with technologies like True Tone displays (which adjust white point based on ambient light), verify that your color choices still look good under those adjustments ￼.
	•	Test on multiple devices and screen types. Ensure your colors render well across the spectrum of devices (older and newer displays, various resolutions). If your app is iPhone-only or iPad-only, test on all supported screen sizes for that device class ￼. For example, an iPhone-only app should still look good on every iPhone model size ￼.

Inclusive color: Design with accessibility in mind when choosing colors. Don’t rely on color as the only way to convey information. In other words, any time color indicates something important (selection, status, error, etc.), also provide a non-color indicator (like a shape, label, or icon) so that people with color blindness or low vision can still understand ￼. For example, instead of just coloring a required field’s border red, you might also show an alert icon or message. Also avoid color pairings that are difficult to distinguish – insufficient contrast can cause text or icons to blend into the background, and certain color combinations (like red/green) may be indistinguishable for color-blind users ￼. Always follow the WCAG contrast guidelines for text legibility (generally a minimum contrast ratio of 4.5:1 for normal text).

Consider cultural meanings of colors. Colors can carry different connotations in different cultures. Make sure the colors you use send the message you intend across your user base ￼. For example, red might signify danger or errors in Western cultures, but in some other cultures red can symbolize good luck or positivity ￼. Such differences mean you should use color cues carefully and not rely on a meaning that could be reversed in another locale.

System colors and dynamic color: iOS and macOS provide a comprehensive set of dynamic system colors for developers. These colors automatically adapt to light/dark mode and are defined semantically (by their intended usage, not by fixed RGB values). For example, there are dynamic colors for primary/secondary/tertiary system backgrounds and for labels, separators, fills, etc., each adjusting as needed ￼ ￼. The HIG advises: Do not hard-code system color values. The documented RGB values of system colors are for reference, but the actual color might vary by iOS release or environmental context (e.g. increased contrast mode) ￼. Always use the API (such as the Color or UIColor/NSColor class) to fetch system colors by name, rather than copying numeric color values ￼. This ensures your app automatically stays up to date with any subtle system color changes. Similarly, don’t try to replicate or override dynamic system colors – use them as intended for consistent results ￼.

Typography

Your typographic choices help ensure readable, hierarchy-aware text that communicates clearly and fits your brand’s style ￼. iOS uses the San Francisco family of fonts as the system UI fonts, which are optimized for legibility. The HIG recommends using dynamic type and the system text styles to automatically get appropriate fonts and sizing. In practice: use the built-in text styles (such as Title, Body, Caption, etc.) so that your app’s text automatically responds to the user’s Dynamic Type settings (larger text for Accessibility, etc.). Designing with these styles means the system can scale text as needed without breaking your layout.

Legibility and scalability: Text should be legible at all sizes. Use fonts and text sizes that are easy to read, and test your app with Larger Accessibility Type turned on to ensure your layout can accommodate it ￼. If you use a custom font, make sure it remains clear at small sizes and that it supports Dynamic Type or at least offers a range of weights/sizes for different content. Avoid using text in images or non-adjustable layers, as it won’t scale.

For interface mockups, Apple’s guidelines note that you should use SF Text for text 19 points or smaller, and SF Display for 20 points or larger, to ensure optimal readability ￼ ￼. The system will automatically switch fonts at the appropriate sizes when you use the built-in styles. Pay attention to tracking (letter spacing) – San Francisco dynamically adjusts tracking for different sizes; if you’re using custom fonts or doing custom text rendering, ensure you account for this so that text isn’t cramped or sparse ￼ ￼.

Also maintain clear hierarchy in typography. Use font weight, size, and style to create a visual hierarchy of headings, body text, and captions that mirrors the content’s logical hierarchy. Don’t use too many fonts or weights which can make the interface feel inconsistent or busy.

Icons and Images

Interface Icons: In-app icons (for toolbar buttons, navigation bar items, tab bar items, etc.) should be clear, simple, and universally recognizable. Create a design that is highly simplified – too much detail in a small icon can make it confusing or illegible ￼. Aim for a single, focused visual metaphor that users will immediately understand (for example, a trash can for “Delete”). All your interface icons in the app should share a consistent visual style ￼. This means using a uniform size and stroke weight, consistent level of detail, and a consistent perspective or angle for all icons. Whether you use all custom icons or mix custom with Apple’s SF Symbols (the system-provided icon library), the final set should look harmonious together ￼.
	•	In general, match the visual weight of icons with any accompanying text ￼. An icon that appears next to a label (for example, in a menu or button) should be stylistically aligned – if text is bold or heavy, an icon with a similar stroke weight will feel balanced. If neither needs emphasis, use similar weights so one doesn’t outshine the other ￼.
	•	If a custom icon appears visually off-center due to its shape (especially for asymmetrical shapes), you can add padding within its bounding box to achieve optical centering ￼. For example, an arrow icon might look low or off-center if simply centered geometrically, so you might pad its top to make it optically centered. Strive for your icons to look balanced in their actual placement, not just mathematically centered.
	•	Generally, don’t include text in icons unless absolutely necessary for clarity ￼. Icons are usually strongest when they are purely graphic. If you must include a letter or word (such as a currency symbol or a single character to denote a concept), localize it for different languages and consider that it may be harder to read at small sizes ￼. Never use interface icons as a substitute for instructions; if a concept is too abstract, a short label or tooltip might be more appropriate than adding a lot of text onto an icon.
	•	Inclusivity in icons: Use imagery in icons that is inclusive and doesn’t rely on stereotypes. The HIG suggests avoiding unnecessary gender markers in icons representing people ￼. Use symbols and metaphors that are familiar to all cultures (or at least the cultures your app serves). For example, a person icon should be neutral, not overtly male or female, unless your app has a specific reason.
	•	Provide different states for icons only if needed. Many system-provided icons (or SF Symbols) automatically convey state (like a filled vs outline star for favorite/not favorite). If your icon doesn’t clearly show its selected or active state, you may need a selected-state version (often a filled/shaded version). But don’t create duplicate icons for state if a simple highlight or system-provided variant will do ￼. For instance, iOS tab bar icons automatically tint to the system accent color when selected, so separate “selected” artwork isn’t needed for those in most cases.
	•	Use the correct file format: If you create custom interface icons, use a vector format (PDF or SVG) so they can scale cleanly ￼. The system will automatically scale a vector-based PDF/SVG icon for all resolutions, eliminating the need to supply separate @2x/@3x raster images ￼. (In Xcode asset catalogs, you can import a single PDF for an icon and have it serve all screen scales.) Do not use bitmaps for icons if you can avoid it – bitmap images (PNG, JPEG) will not scale gracefully and you’d need to provide multiple sizes for different devices ￼. (PNG is still fine for complex artwork or photos, but for flat interface icons, vectors are superior.) If an icon includes shading, textures, or complex effects such that you must use a bitmap, be prepared to provide @1x, @2x, @3x versions for different screens ￼. Alternatively, consider creating a custom SF Symbol (using Apple’s SF Symbols tool) which can then behave like a native icon, automatically scaling and even inheriting dynamic weight adjustments.
	•	Alternate text (accessibility): Ensure that every meaningful icon has a accessible label. In practice, set an appropriate accessibilityLabel for icons that aren’t accompanied by text. For example, a gear icon might be labeled “Settings” for VoiceOver users. These labels aren’t visible in the UI, but they allow VoiceOver to announce the icon’s purpose ￼. (If you use SF Symbols or system UIBarButtonItems, often the system provides a default label, but you should verify it’s appropriate.) Providing alternative text is crucial for blind or low-vision users to navigate your app’s interface ￼.
	•	Avoid using images of Apple hardware in your UI. Do not use replicas of Apple products (like the shape of an iPhone or the Apple logo) in your app’s icons or imagery ￼. Hardware designs change frequently, and using these can make your app feel outdated or even violate App Store guidelines. If you need to depict an Apple device or use such imagery (say, to illustrate a tutorial), use official resources – Apple provides device images and templates in the Apple Design Resources ￼. Or use SF Symbols that represent devices (for example, SF Symbols has icons for iPhone, iPad, Apple Watch, etc.).

Images and graphics: When using photos or illustrations in your app, ensure they are high quality and appropriate for both Light and Dark appearances (consider using translucency or overlays in dark mode if needed to keep images from clashing with dark backgrounds). Optimize image file sizes to balance fidelity and performance – large images should be compressed (PNG for lossless or JPEG for photographic content). Provide the right image scale factors (@2x, @3x) for any bitmap images to appear crisp on Retina screens. If your app displays imagery that might be cropped (like a content feed with aspect-fill thumbnails), be mindful of aspect ratios so important content isn’t cut off. The HIG advises maintaining the aspect ratio of images; do not distort images to fill space ￼. Instead, if an image must fill a different aspect container, use cropping that retains key content, or use letterboxing/pillarboxing if necessary rather than stretching.

Accessibility and Inclusion

(See also the separate Accessibility guidelines in the HIG for more detailed best practices.) Making your app accessible ensures that everyone can use it, regardless of ability. An accessible app or game is one that, by design, supports the accessibility features people use to customize how they interact with their devices ￼. Approximately one in seven people has some form of disability that affects how they use technology ￼ – and even users without permanent disabilities may experience situational limitations (for example, an injury making one hand unusable, or being in a loud environment where they can’t hear). Designing with accessibility in mind benefits all users.

Some key points from the HIG’s accessibility section:
	•	Design with accessibility in mind from the start. This means prioritizing simplicity and perceivability in your UI, and examining every design decision to ensure it doesn’t exclude users who have different abilities or interact in different ways ￼. Two fundamental principles Apple highlights are Simplicity – keep interactions familiar and tasks straightforward; and Perceivability – make sure all content can be perceived whether someone is using sight, hearing, or touch ￼.
	•	Support personalization: Just as you adapt to different screen sizes or orientations, adapt to different Accessibility settings. For example, when the user enables Bold Text or Larger Text, your app’s text and controls should respond automatically if you use standard components ￼. Using standard UIKit controls typically gets you this support for free (since, e.g., a UIButton will automatically enlarge text for Larger Text settings). Test your app with various accessibility settings on (like VoiceOver, Zoom, Increased Contrast, Reduce Motion) to ensure it remains usable.
	•	Audit and test your app’s accessibility: Use tools like Xcode’s Accessibility Inspector or VoiceOver to audit every screen ￼. An audit can reveal missing labels, low-contrast text, small hit areas, etc., and provide a list of issues to address. Then perform usability testing with those features – e.g., try navigating your app using VoiceOver only, or try it with Switch Control – to truly understand the experience challenges ￼. Ensure that the core tasks in your app can be accomplished by someone who can’t see the screen or can’t hear audio feedback, etc.
	•	Provide useful alternatives: For all non-text content, provide text alternatives (e.g., accessibility labels for icons as mentioned, descriptive captions for media if needed). Ensure your Focus order (the order in which VoiceOver or keyboard navigation moves through elements) makes sense logically. Avoid animations or interactions that are impossible for certain users (and respect the Reduce Motion setting by toning down or disabling parallax/animations if it’s on).

(For more details, refer to Apple’s Accessibility guidelines which cover a wide range of topics, from VoiceOver and Switch Control to color contrast and more ￼.)

Layout and Organization

Thoughtful layout ensures your app’s interface is adaptable, efficient with space, and easy to navigate. Design your UI to dynamically accommodate different device sizes, orientations, and user preferences. Here are key guidelines related to layout:
	•	Use adaptive layouts (Auto Layout / SwiftUI) to support all screen sizes. Your app’s UI should gracefully adapt to the variety of iOS devices – from the smallest iPhone SE to the largest iPhone Pro Max. Avoid hard-coding coordinates or assuming a fixed screen size. By using Auto Layout or SwiftUI’s responsive layout system, you can create interfaces that automatically adjust when, for example, the device rotates or when running on a different screen size. Adaptivity also means using size classes and safe areas appropriately to rearrange or resize content in different contexts (like iPad multitasking splits).
	•	Respect safe areas. The safe area defines the portion of the screen not covered by system UI elements (status bar, notch, navigation bar, tab bar, home indicator, etc.) ￼. By constraining your content to the safe area, you ensure that interactive elements aren’t obscured or difficult to reach. In practice, this means using layout guides (like UILayoutGuide or SwiftUI’s SafeArea) to position content. Do not place important content or controls under the notch, status bar, or home indicator – always inset as needed to stay within the safe area bounds ￼. When using full-width images or backgrounds that can extend edge-to-edge, make sure any critical parts of those images are not in the non-safe regions or they might get clipped on certain devices.
	•	Provide adequate spacing, but don’t waste space. Use padding and margins consistently to create a comfortable, open design – but be mindful of small screens where excessive padding can waste precious space. In general, minimize unnecessary padding between elements so you can show more content on smaller displays ￼. Apple encourages using standard system spacing as a guide (for instance, Interface Builder’s default constraints).
	•	Avoid over-cluttering with controls in one line. Specifically, the HIG says: Avoid placing more than two or three controls side by side in your interface. As a rule of thumb, at most three icon-only buttons or two text buttons should be in one row ￼. If you have multiple actions, consider other arrangements (like a segmented control, a toolbar, or a menu) rather than a long row of buttons. It’s usually better to let buttons expand to full width on narrow screens, instead of cramming several small buttons next to each other ￼. Two side-by-side short text buttons can work if the screen is wide enough and the content doesn’t scroll, but in most cases, simpler layouts are superior ￼.
	•	Design for both portrait and landscape. Users might rotate their device deliberately (to see more content or just by habit). Unless your app is explicitly portrait-only (or landscape-only, like some games), aim to support both orientations ￼. This means your layout should rearrange intelligently on rotation. For example, a two-column layout in portrait might become a wider single row in landscape, or you might show sidebars or multi-panel views in landscape on iPhone that aren’t shown in portrait. If your app only runs in one orientation, don’t lock it without reason, and don’t instruct users to rotate – if they happen to rotate and your app doesn’t support it, the system will keep it in the allowed orientation (or show a rotation UI lock for apps that only support one orientation) ￼. If an experience truly must be one orientation (e.g. a game that plays only in landscape), support both directions (left home button vs right home button) for that orientation so the user isn’t forced to a single way of holding the device ￼.
	•	Account for various device configurations. If your app runs on a specific device type, make sure it runs on every screen size of that type ￼. For instance, an “iPad-only” app should work on all iPad screen sizes (iPad mini through iPad Pro); an “iPhone-only” app on all iPhone sizes ￼. Use Xcode’s preview or Simulator to test on different model sizes, and adjust your layout constraints as needed.
	•	Touch target sizing: All touchable controls should have a minimum tappable area of 44×44 points ￼. This doesn’t mean every button icon must be 44pt wide, but the clickable region (with padding) should be at least that. This ensures controls are easy to hit without needing perfect accuracy, which is especially important for accessibility (for users with larger fingers or motor impairments). In practice, avoid tiny buttons or sliders that require precise tapping. If you have a small icon, increase its hit area by adding invisible padding around it (UIButton in iOS can do this automatically if you set the contentEdgeInsets, for example).
	•	Layout for localization: Text length varies in different languages. Design your layout to accommodate longer translated strings. Use Auto Layout with flexible width constraints or allow labels to wrap to multiple lines if necessary. Also consider right-to-left (RTL) languages like Arabic or Hebrew – iOS can automatically flip the interface for RTL (if you use standard UIKit components and Auto Layout). Ensure your images or icons that convey direction also flip in RTL (use asset catalogs’ Right-to-left settings or SF Symbols which support RTL mirroring) ￼ ￼. Test your app with an RTL pseudolanguage or by force mirroring to catch any layout issues.
	•	Avoid putting interactive controls at the very bottom edge when possible. The system uses the bottom edge (on modern iPhones with no Home button) for the home gesture and app switching gestures. Controls located fully at the bottom can conflict with these. If you have important controls near the bottom, make sure they are above the home indicator or sufficiently inset from the screen edge so that the gesture area doesn’t overlap them ￼ ￼. (For example, in games that have a virtual joystick or buttons at the bottom, it’s recommended to position them a bit above the exact screen bottom and to leave a comfortable margin around the home indicator.) Also avoid putting controls in the extreme corners where they’re hard to reach comfortably ￼. In general, align bottom controls with the safe area’s bottom inset so that they sit just above the home indicator on iPhones ￼.
	•	Handle the status bar area elegantly: Different devices (or even calls in progress, etc.) can produce different status bar heights. Use safe-area layout guides to automatically adjust content if the status bar height changes (for example, during an active phone call on iPhone, the status bar doubles in height) ￼. Don’t place fixed content underneath the status bar; if you must draw under it (like a full-screen image background), ensure important parts of the UI are not obscured. Also, don’t hide the status bar unless necessary. The status bar provides valuable system info (time, signal, battery) and occupies very little space – most apps should leave it visible ￼. Only hide it if your app benefits from the extra space or immersive experience (like a game or video player), and even then, consider showing system info elsewhere if needed.
	•	Preview on multiple devices and scenarios: Use Xcode’s Simulator or SwiftUI previews to see how your layout handles different screen sizes, orientations, and even text size settings ￼. There are features like “Preview as: Dynamic Type XXXL” to test larger font. If your app supports both orientations, test that your views re-layout properly on rotation (no weird clipping or overlapping). Also, test with long text (e.g., change the language to German or Russian which often have longer words) to see if labels truncate.

By adhering to these layout principles, your app’s UI will be flexible, responsive, and comfortable on any iOS device, providing a great experience in all conditions.

Navigation and Structure

Navigational structure is how users move through your app’s content. A well-designed navigation scheme makes it easy for people to find what they need and understand where they are. iOS provides standard navigation frameworks – use them to meet user expectations:
	•	Choose the appropriate navigation paradigm: Common structures on iOS include hierarchical navigation (drill-down using Navigation Bars and stacks of screens), flat tab-based navigation (multiple peer sections using a Tab Bar), and content-driven or experience-driven navigation (like a camera app that’s mostly one primary view with modal options). The Human Interface Guidelines recommend using a Tab Bar for an app with multiple primary sections (modules) and keeping the tab bar visible at all times for easy access ￼. Each tab should correspond to an essential category of functionality. Don’t hide the tab bar when users navigate deeper (except when presenting modal views or subtasks) ￼ – the consistency of the tab bar helps users switch sections from anywhere in the app.
	•	Use standard UI navigation components. For hierarchical flows, use a UINavigationController with a Navigation Bar to automatically provide a back button and title. The back button on iOS should always navigate one level up in the hierarchy. Ensure the back button’s label shows the title of the previous screen (so users know where “Back” will take them) ￼. (By default, UINavigationController does this for you if each screen has a title.) Don’t arbitrarily change the back button’s behavior or label. For example, if Screen A goes to Screen B, and Screen B’s back button should say “A” (the title of Screen A) ￼.
	•	Maintain context when navigating. The app’s current screen title (in the navigation bar) should succinctly describe the content or section. Use large titles on the initial screens if appropriate (the system large title style can make top-level screens more prominent, e.g., the main list in Settings app has a large title). As users drill down, the standard nav bar ensures they can go back. If your app uses gestures for navigation (like swipe right to go back), ensure there is also a visible way to navigate (the back button) for discoverability.
	•	Don’t remove or repurpose standard navigation elements. For instance, if a tab in your Tab Bar temporarily has no content, do not remove the tab entirely – this would shuffle the UI and confuse users ￼. Tabs represent stable sections of the app. If a section is unavailable, you can disable content within it or show an empty state message, but the tab itself should remain. Similarly, avoid hiding the navigation bar or back button in an attempt to “simplify” unless you have a good reason – users expect those to be there and will try to use them. Consistency with platform conventions builds trust.
	•	Use toolbars or menus for contextual actions. If you have multiple actions that apply to the current screen (especially on iPad), you might use a Toolbar at the bottom or top or a navigation bar button that reveals an actions menu. Group less-important actions in an Action sheet or overflow menu if needed to avoid crowding the interface.
	•	Include search if applicable: If your app contains a large amount of content (e.g. list of items, documents, messages), provide a search field (using UISearchBar or SwiftUI’s SearchBar) in a consistent location. Often this is in the navigation bar or a pull-down gesture on the table list to reveal search. Follow the iOS pattern for search – for example, in a list view, pulling down to reveal a search field at the top is a common and intuitive gesture.
	•	Maintain logical navigation hierarchy: Users should never feel lost. Provide clear back navigation, but also avoid deep nesting when possible. If you find that users need to go 6-7 screens deep, consider redesigning your information architecture (maybe use modal flows for certain tasks or flatten the hierarchy by using a table of contents or split view on larger screens).
	•	Modal presentations: Use modals (presented view controllers) for self-contained tasks or separate flows that don’t fit into the navigation hierarchy (for example, composing a new email is often a modal). When you present a modal, clearly indicate a way to dismiss it (Done/Cancel button). Modals on iPhone typically slide up from the bottom and cover most of the screen. Use them sparingly – if a task can be done within the navigation stack, that’s often preferable. According to HIG Patterns, modals (and other modes) should not surprise the user; always make the transition obvious and provide a cancel. When a modal is dismissed, the user should return exactly to where they left off in the main flow.
	•	Tab bar usage: As noted, a Tab Bar is ideal for top-level sections. Use between 2 and ~5 tabs (more than 5 becomes cluttered; if you have more, consider a “More” tab or rethink the structure). Label tabs clearly (short labels). Use simple, filled icon glyphs for tabs that convey meaning even without text (and provide the text label for clarity). The tab bar should remain visible and consistent across the app (do not dynamically add/remove tabs on the fly). One specific guideline: Don’t remove a tab just because its content is unavailable – for example, don’t hide a “Notifications” tab when there are no notifications; instead show an empty state ￼. Users memorize the location of tabs, and removing one will disrupt this muscle memory and confuse them.
	•	Breadth vs depth: Prefer breadth in navigation hierarchy rather than extreme depth. It’s usually easier for users to choose from a menu of options than to keep tapping through a long chain of screens. That’s why tab bars (breadth) combined with shallow navigation hierarchies work well for many apps.
	•	Consistency: Keep navigation mechanisms consistent throughout your app. If swiping right goes back on one screen, it should do the same on every screen that’s in a hierarchy. If tapping a particular icon always takes you to a certain section, don’t repurpose that gesture elsewhere.
	•	State preservation: If a user switches tabs or leaves the app and comes back, preserve their navigation state when possible. For example, if they were three levels deep in a particular section, don’t reset to the root when they return unless memory constraints forced a reset. It’s good to save navigation stacks’ state so the app feels continuous.

By following these navigation guidelines, your app will feel intuitive: users will always know where they are, how to go back, and how to get to the main parts of your app.

Controls and User Interaction

Interactive controls are the building blocks of your interface (buttons, switches, text fields, etc.), and how you respond to user actions defines the overall feel of your app. The HIG offers these core guidelines for controls and interactions:
	•	Use system-provided controls whenever possible. Standard UI controls (like UIButton, UISegmentedControl, UISlider, etc.) not only have a familiar look and behavior, but also automatically adapt to user settings (like Bold Text, Larger Text) and device theme changes. They also come with built-in accessibility. Only create a fully custom control if you need a completely unique interaction that UIKit doesn’t offer. Even then, mimic the style and behavior of similar native controls so it feels “at home.”
	•	Size controls appropriately: As mentioned, ensure a minimum tap target of 44×44 points for any control ￼. This means even if an icon is 20×20 pt, it should have at least 12 pt padding on all sides (making the tappable area 44×44). This guideline comes from Apple’s ergonomics research – it’s the smallest comfortable size for an average fingertip. Larger is fine, especially for primary call-to-action buttons, but avoid anything smaller.
	•	Labels on controls: Use clear, succinct text on buttons and other labeled controls. Prefer verbs or verb phrases on action buttons (e.g., “Save”, “Add”, “Send”). If space is tight, use standard icons or SF Symbols alongside or in place of text, but ensure their meaning is obvious. For icon-only buttons, supply an accessibility label (e.g., a trash can icon should have an accessibilityLabel “Delete”).
	•	Feedback and responsiveness: Always provide immediate visual feedback when a control is activated. For example, when a button is tapped, it should briefly highlight or change appearance to indicate it’s being pressed ￼. If tapping triggers a longer process, show a progress indicator or at least disable the control and re-enable when done. Users expect instant feedback; without it, they may think the tap didn’t register. iOS controls by default provide highlight states – ensure those are not removed. For list selections or other interactions, provide subtle feedback like a cell highlight or selection checkmark so the user knows their action was received ￼. If appropriate, use sound or haptic feedback to augment the experience (for example, a toggle switch might click, or a success might trigger a brief haptic tap – but always as a supplement to visual feedback, not a replacement).
	•	Consistency in controls usage: Use the right control for the right job, consistently. For example, use a switch for a binary on/off setting (as per iOS style), a segmented control for switching between multiple views or modes in place, and steppers for small increments. Don’t repurpose a control in an unconventional way; this will confuse users. Follow the principle of least surprise – a control should do what it looks like it does.
	•	Avoid too many custom gestures or controls on screen at once. If your interface has many interactive elements, consider grouping some actions into a menu or using progressive disclosure (e.g., tap “Edit” to reveal editing controls, rather than showing edit controls for every item by default). A clean interface with only the relevant controls displayed is less overwhelming.
	•	Gestures: Support common system gestures consistently. For instance, a table view by default supports swipe-to-delete; if you have similar content, use the same gesture for delete. Do not override standard navigation gestures (like the back-swipe) for some other purpose – that will frustrate users who use that gesture habitually. If you introduce a custom gesture (like a custom two-finger pan or a long-press with a custom outcome), consider also providing a visible UI control for that action, or an onboarding hint, because not everyone will discover an undocumented gesture.
	•	Touch interactions: Keep in mind that touch is a direct form of interaction. Elements should respond not only to taps but also consider touch nuances: e.g., implement drag reordering in lists if it makes sense, use swipe actions for quick options on list items (as Mail and other apps do), etc. Ensure that interactive elements are easily distinguishable from static content (through affordances like button borders, disclosure indicators, etc., or through careful layout).
	•	Prevent accidental taps: If an action is destructive or not easily reversible, consider requiring a confirmation (via an alert) or use a two-step gesture (like the swipe-to-delete which requires an extra tap on the “Delete” button that appears). Additionally, spacing out controls helps prevent accidentally hitting the wrong one. For example, on toolbars, use the system spacing guidelines between icons.
	•	Keyboard and focus (where relevant): If your app involves text input, automatically focus the appropriate field when a screen appears (but don’t unexpectedly summon the keyboard if it would obscure content). Provide a Done button or return key action to dismiss the keyboard. If your app uses external keyboard support (on iPad), ensure that UI focus follows expected patterns (e.g., arrow keys navigate lists, etc.) – though iOS does much of this by default if your controls are properly accessible.
	•	Always test user flow: When the user performs an action (taps a button, toggles a setting), does something visible happen? Does the UI update to reflect the new state? Always keep the user informed. For longer operations, use an activity indicator or progress bar to show that work is happening. Provide descriptive messages for any errors (e.g., “Connection lost. Try again.”) rather than failing silently.
	•	Animation and motion: Use motion effects thoughtfully to clarify interactions, not to distract. Animations should generally be subtle and quick, reinforcing the result of the user’s action (for instance, tapping a button might animate a new screen in from the side, making it clear that a new view has appeared as a result). Avoid heavy or gratuitous animations that can slow down the perceived responsiveness. Also, respect the Reduce Motion setting by toning down or disabling non-essential animations if the user has it on (e.g., replace parallax effects with static images).

In summary, every control in your app should be easy to tap, behave as expected, and provide clear feedback. By following these guidelines, you ensure that interaction with your app feels natural and satisfying on iOS devices.

System Capabilities and Integration

iOS offers a wide array of system capabilities – from iCloud and Notifications to Apple Pay and Health – that apps can integrate. The HIG encourages developers to integrate system features in a way that feels seamless to the user. Leverage these capabilities while respecting user privacy and platform conventions:
	•	iCloud and Continuity: If your app deals with user-created content or data, support iCloud synchronization so their information stays up-to-date across all their devices. Implement it in a way that’s transparent – users generally expect their data to sync without extra effort. As Apple’s guidelines note, “Support iCloud storage simply and transparently” ￼. Don’t make users deal with import/export; use file providers or CloudKit so data is just “there” on their other devices (with appropriate user consent). Likewise, handle continuity features (like Handoff between iPhone and Mac) if relevant – for example, a user working on a document in your iPhone app should be able to seamlessly continue on their Mac.
	•	Multitasking and backgrounding: Be prepared for interruptions. iOS apps can be interrupted by phone calls, Siri, notifications, etc., or put into background when the user switches apps. Your app should save state at sensible points (e.g., on entering background) so that if it’s terminated, it can restore to where the user was. Also, respond properly to multitasking on iPad (if you support iPad) – support Slide Over and Split View by adapting your layout (use Auto Layout and size classes to adjust when your app is in a smaller split window). Ensure that when your app is in the background, you pause any unnecessary processes to save battery, unless you have a special background task (like playing audio or completing an upload). Apple emphasizes being ready to resume quickly and correctly when returning from interruptions ￼.
	•	Notifications: If your app uses push notifications or local notifications, follow the guidelines for requesting permission and only do so when your app’s value is clear. Users can be sensitive about allowing notifications. Provide a contextual prompt or explanation (perhaps a screen that explains why you’d like to send notifications) before the system permission dialog. And respect the user’s Notification settings – e.g., if they’ve disabled certain notification types in Settings, abide by that. As Apple says, “Comply with the user’s Notification Center settings when sending local or push notifications.” ￼. In the UI, don’t nag the user to enable notifications if they’ve declined; instead, maybe provide a one-time prompt or a toggle in your settings that leads them to the system Settings if they choose.
	•	Location and privacy permissions: The HIG strongly encourages transparency with any feature that accesses user data or sensors (location, contacts, photos, etc.). Only request permission at the moment it’s needed – for example, don’t ask for location access on first launch if it’s not immediately required. When you do request, provide a purpose string in the system alert that clearly explains how granting permission benefits the user. Never surprise users with why you need something. Moreover, if you have a custom pre-permission screen (to explain the benefits before the system alert), include only one clear action button that leads to the system alert ￼. Do not use misleading wording like “Allow” on your own button, which could make users think they already granted permission – instead, use something like “Continue” or “Next” to indicate it will proceed to ask for permission ￼. Always give people a way to opt out or cancel at that point. And if the user says no, respect that – don’t continuously prompt or degrade the experience; perhaps offer the functionality in a limited way and provide info on how to enable permission later if they want.
	•	Security and sensitive data: Protect user data by using the system-provided secure storage. Store sensitive information in the Keychain rather than in plain files ￼. The Keychain is encrypted and secure, and it provides a consistent way to handle things like passwords or tokens with proper security. Never store passwords or personal data in plaintext on disk ￼. Also, avoid inventing your own encryption or authentication schemes when the system provides trusted ones. For example, prefer using Sign in with Apple or OAuth with third-party providers over asking for raw passwords, and use Face ID / Touch ID (Local Authentication) through the system APIs if possible instead of a custom PIN system ￼ ￼. Apple explicitly says: Avoid relying solely on passwords for authentication. Take advantage of technologies like Touch ID (Face ID) for a better user experience. ￼ and Don’t invent custom auth schemes when you can use system-provided services like Sign in with Apple or AutoFill ￼. Not only do these make your app more secure, they also make it easier for users (no extra passwords to remember).
	•	Apple Pay and Wallet: If your app involves purchases or payments, consider using Apple Pay for a fast, secure checkout experience. Follow the Apple Pay Human Interface Guidelines: use the provided Apple Pay button graphics (do not alter them), and only show the Apple Pay option if the user’s device/config supports it. If using Wallet passes, use the standard templates and avoid mimicking them in non-standard ways.
	•	Health, Home, other frameworks: When integrating with system apps or frameworks (HealthKit, HomeKit, etc.), abide by their specific guidelines for user data handling. For example, HealthKit data is sensitive – provide meaningful context for why your app wants to read or write health data, and ensure your UI reflects data from the Health app accurately. For HomeKit, use the HomeKit Accessory Simulator during development to test, and present a UI that feels like a natural extension of the Home app (icons, terminology consistent).
	•	Shortcuts and Siri: If appropriate, donate Siri Shortcuts for frequent user actions (so they can be voice-triggered). Provide clear, succinct Siri phrases for your shortcuts. If using SiriKit intents, handle the intent interactions gracefully (provide custom Siri UI if needed to confirm actions, etc.). Also, ensure your NSUserActivity for handoff and Spotlight indexing properly represent content (so users can search for content in your app via Spotlight).
	•	Extensions and Notifications UI: If your app provides extensions (like iOS Widgets, Notification Content extensions, or Apple Watch app), design those consistently with your app’s style but also within the guidelines of those contexts. For widgets, make them glanceable and don’t overload them with interaction. For watchOS apps, follow Apple Watch HIG guidelines (e.g., brief interactions, dark backgrounds, etc.).
	•	Performance and battery: Using system frameworks often ensures better performance (as they are highly optimized). Avoid doing something in an inefficient way that the system can handle for you. For example, if you need background fetch, use the Background Fetch API rather than keeping a background task running continuously. Respect energy guidelines: if your app uses location in background, use the most appropriate (e.g., “when in use” vs “always”) and disable it when not needed. The system will prompt users if an app is using location in background excessively – design your usage to be justifiable.
	•	Follow App Store and privacy guidelines: This is broader than HIG, but aligns with it: design your data usage to follow Apple’s privacy principles (data minimization, transparency, control). If your app might need to explain privacy practices, do so in-app as well (especially since users see privacy “nutrition labels” on the App Store now). For instance, if you collect usage analytics, perhaps offer an opt-out toggle in Settings.

In sum, take advantage of system capabilities to enhance your app – they can provide features users already trust and understand – but implement them in a user-centric way. Always get proper consent for personal data access, provide clear value for permissions, and prefer system-provided solutions (which are often more secure and familiar) over custom ones. By adhering to these practices, your app will not only be more powerful but also feel like a natural, integrated part of the larger Apple ecosystem, which users appreciate.

Visual Design and Aesthetics

(Finally, a note on overall visual design principles that Apple encourages, tying together many of the above topics:)

Apple’s design philosophy for iOS can be summarized by three tenets: Clarity, Deference, and Depth. Your app’s interface should present content clearly at every opportunity, defer to the iOS UI conventions so that it feels at home and doesn’t overwhelm the user, and use visual layers and transitions to convey depth and context. Some guidelines that reflect these principles:
	•	Clarity: Use legible text at an appropriate size, high-contrast color schemes, and clear iconography. Every screen should have a single primary focus or action (especially on iPhone’s relatively small screen). Remove or downplay secondary information or controls that aren’t immediately needed. Clarity also means naming things simply (use terminology the user will understand, not internal jargon). For instance, label a button “Send Feedback” rather than “Submit Incident Report” if the former is what a user would expect. Ensure icons and graphics clearly communicate their meaning (test them with users or colleagues – do they get the right idea at first glance?).
	•	Deference: The UI chrome (buttons, bars, backgrounds) should never compete with the content. Use translucent bars and minimal drop shadows to create hierarchy without drawing too much attention. iOS’s default aesthetic uses blurs and translucency to hint at layers without heavy borders or stark separation. Adopt a similar approach: prefer content-first design, where, for example, a photo gallery app’s bars might fade or slide away while viewing photos, letting the photo shine. Choose a neutral or appropriate background for your content – white or lightly tinted backgrounds for text-heavy pages (to maintain readability), or black backgrounds for media that benefits from contrast (like a photo viewer, where a black background recedes and the photo pops).
	•	Depth: Utilize transitions and motion to help users understand navigation. iOS uses layered views and transitions (e.g., pushing a new view slides it in from the right, implying a new layer in the hierarchy). Use these standard transitions to your advantage rather than custom animations that might confuse. Also consider using subtle shadows or scaling to denote depth (for example, a modal sheet might have a shadow or a dimming background behind it to indicate it’s on top of the previous context). Parallax effects on iOS (tilting to see under icons) illustrate a sense of depth; you might not implement your own parallax, but understand the concept of layers in interface design.
	•	Branding and custom appearance: Infuse your app with brand personality (through color, typography, and style) but keep it subtle and consistent. Apple advises against heavy-handed branding that overshadows usability ￼ ￼. For example, don’t fill every screen with logos or slogans – the user knows what app they’re in. Instead, express branding through the choice of accent color, the style of icons, maybe a custom font for headings, or a distinctive illustration style. Make sure that branding elements do not reduce clarity (e.g., a background image with a logo watermark might make text hard to read – not a good trade-off). The best apps create a memorable experience while still feeling clean and user-focused.
	•	Alignment and spacing: Follow grid and alignment guidelines. Left-align text to the natural reading position (except when center alignment is obviously better, like a short label or a title). Use consistent margins (iOS standard is typically 16px margins from the screen edge for content on iPhone, but use the safe area and Interface Builder’s guides). Ensure controls and text baselines align neatly – a visually ordered layout feels more polished and is easier to parse.
	•	Graphics and blurs: If your app uses blurs or vibrancy (as many iOS system UIs do), use them appropriately – for example, a sidebar or popover can have a blurred backdrop to indicate it’s overlaying content. Apple’s UIBlurEffect can create these translucent panels that match system style. Use vibrancy (via UIVibrancyEffect) for content placed on blurred backgrounds so it stands out (like white text on a blur). These effects, when used tastefully, can give your app an unmistakably iOS aesthetic.
	•	Icons and imagery: Keep them consistent (as discussed) and use SF Symbols when possible for universal icons (like share, add, etc.). SF Symbols ensures your icons automatically adopt the weight and scale appropriate for text around them, which helps consistency.
	•	Terminology: Use Apple’s standard terminology for common things to avoid confusion. For instance, use “Edit” for editing mode buttons, “Done” to finish, “Settings” not “Preferences”, “Search” for search features, etc. Consistent terminology helps users intuitively know what actions will do.
	•	Empty states: Design states for when content is empty or an error has occurred. An empty list view, for example, should show a friendly message or illustration encouraging the user to take action (like “No items – tap + to add a new item”). These states should be visually consistent with the rest of your app but slightly more prominent to provide guidance. Use encouraging language and perhaps a call-to-action button right there.
	•	Loading states: If content may take time to load, use placeholders or skeleton views to avoid a sudden jump or a blank screen. Apple’s large apps like Mail show a ghost text when loading new messages, for example. A fast apparent response (even if just a placeholder) makes the app feel responsive.

In conclusion, designing for iOS means striking a balance between following the proven interface patterns that users know and love, and expressing your app’s unique identity. The Human Interface Guidelines distill decades of learnings about what makes an app not just look good but feel right on an Apple device. By adhering to these guidelines – using the appropriate controls, spacing, typography, color, and system features – you can create an app that is intuitive, beautiful, accessible, and engaging, providing a great user experience that feels at home on iOS.

⸻

Sources: The content above has been compiled and quoted from Apple’s official Human Interface Guidelines for iOS, as found on Apple’s developer site ￼ ￼ ￼, along with related documentation and best practices described therein ￼ ￼. All sections and quotes are taken directly from or based on the Apple HIG documentation, preserving the original structure and wording as much as possible, covering platforms, foundations (color, typography, icons, etc.), patterns (navigation, feedback, permissions), components (controls, safe areas, etc.), inputs (touch gestures), and technologies (system integrations) in the iOS Human Interface Guidelines. ￼ ￼ ￼ ￼
